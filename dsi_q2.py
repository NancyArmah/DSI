# -*- coding: utf-8 -*-
"""DSI_Q2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1loGbGa8GPYCoEy75bhIZs31fkSMRM4nN
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

"""# Q.1"""

df1=pd.read_csv('data.tsv', sep='\t')

df1.head(10)

df2=pd.read_csv('data-2.tsv', sep='\t')

df2.head(10)

df3=pd.read_csv('data-3.tsv', sep='\t')

df3.head(10)

"""# Q.2"""

duplicate=df1[df1.duplicated()]
print(duplicate)

duplicate=df2[df2.duplicated()]
print(duplicate)

duplicate=df3[df3.duplicated()]
print(duplicate)

df1.duplicated().sum()

df2.duplicated().sum()

df3.duplicated().sum()

df2.rename(columns = {'titleId':'tconst'}, inplace = True)

df2.head()

"""# Q.3"""

#Inner Merge
merged_df = pd.merge(pd.merge(df1,df2,on='tconst'),df3,on='tconst')

merged_df.head()

len(merged_df)

merged_df['titleType'].unique()

merged_df['titleType'].nunique()

"""# Q.4"""

df_new = merged_df[(merged_df['language'] == 'en') | (merged_df['region'] == 'US') & (merged_df['titleType']== 'movie') ]

"""# Q.5"""

df_new.head()

df_new[df_new['log10Votes'] == np.log10(df_new['numVotes'])]

"""# Q.6"""

df_new['genres']=df_new['genres'].str.lower()

df_new.head()

df_new.groupby('genres')['log10Votes'].mean().nlargest(10)

df_new.groupby('genres')['averageRating'].mean().nlargest(10)

"""## Q.7"""

newgroupby = df_new.groupby(['averageRating']).mean()
newgroupby.reset_index(inplace=True)
plt.scatter(newgroupby['averageRating'], newgroupby['log10Votes'])

newgroupby.head()

len(newgroupby)

"""## Q.8"""

# Commented out IPython magic to ensure Python compatibility.
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline

X = np.array(newgroupby['averageRating']).reshape(-1,1)
y = np.array(newgroupby['log10Votes']).reshape(-1,1)

from sklearn.linear_model import LinearRegression
regressor = LinearRegression()
regressor.fit(X, y)

y_pred = regressor.predict(X)

plt.scatter(X, y, color = 'red')
plt.plot(X, y_pred, color='blue')
plt.xlabel('averageRating')
plt.ylabel('log10Votes')
plt.show()

"""Linear Regression Using Scipy"""

from scipy import stats
from scipy.stats import linregress
from scipy.optimize import minimize

x = np.array(newgroupby['averageRating'])
y = np.array(newgroupby['log10Votes'])

slope, intercept, r_value, p_value, stderr = linregress(x, y)

plt.scatter(x,y, color="red", marker="o", label="averageRating vs log10Votes")
 
 
y_pred = intercept + slope*x
plt.plot(x,y_pred, color="green", label="Fitted line")
 
plt.legend(loc='best')
plt.xlabel('averageRating') 
plt.ylabel('log10Votes')

import torch
import torch.nn as nn
from torch.autograd import Variable

x_values = np.array(newgroupby['averageRating'], dtype=np.float32).reshape(-1,1)
y_values = np.array(newgroupby['log10Votes'], dtype=np.float32).reshape(-1,1)

class LinearRegression(nn.Module):
    def __init__(self, inputSize, outputSize):
        super(LinearRegression, self).__init__()
        self.linear=nn.Linear(inputSize, outputSize)
        
    def forward(self, x):
        out=self.linear(x)
        return out

inputDim = 1        
outputDim = 1       
learningRate = 0.01 
epochs = 100

model = linearRegression(inputDim, outputDim)
if torch.cuda.is_available():
    model.cuda()

criterion = torch.nn.MSELoss() 
optimizer = torch.optim.SGD(model.parameters(), lr=learningRate)

for epoch in range(epochs):
    # Converting inputs and labels to Variable
    if torch.cuda.is_available():
        inputs = Variable(torch.from_numpy(x_values).cuda())
        labels = Variable(torch.from_numpy(y_values).cuda())
    else:
        inputs = Variable(torch.from_numpy(x_values))
        labels = Variable(torch.from_numpy(y_values))

    optimizer.zero_grad()

    outputs = model(inputs)

    loss = criterion(outputs, labels)
    print(loss)
    loss.backward()

    optimizer.step()

    print('epoch {}, loss {}'.format(epoch, loss.item()))

with torch.no_grad(): 
    if torch.cuda.is_available():
        predicted = model(Variable(torch.from_numpy(x_values).cuda())).cpu().data.numpy()
    else:
        predicted = model(Variable(torch.from_numpy(x_values))).data.numpy()
    print(predicted)

plt.clf()
plt.plot(x_values, y_values, 'go', label='True data', alpha=0.5)
plt.plot(x_values, predicted, '--', label='Predictions', alpha=0.5)
plt.legend(loc='best')
plt.show()

